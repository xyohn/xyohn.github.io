[{"title":"Upgrade Nacos to 2.2.x","url":"//posts/nacos/nacos-upgrade-2.2.x.html","content":"\n## 前言\n\nNacos 确实是一款不错的产品，但奈何文档写的..不清晰\n\n关于 2.x 版本间的升级，看似好像无坑，实际上还是存在一些配置的变动引发的小坑，特此记录\n\n本文是从`2.0.3`版本升级至`2.2.4`(实际上为`2.2.3`)版本，理论上`2.x`版本间升级均可参考食用\n\n## 升级流程\n\n- 如果使用 Nacos `2.0.x`版本，先确保是否已经关闭双写开关\n  有关双写开关相关信息，可参阅https://nacos.io/zh-cn/docs/v2/upgrading/2.0.0-upgrading.html\n\n- 相比 Nacos `2.0.x`版本，`2.1.x`+数据库结构有以下变动，以下为 MySQL 下的语句，需要在升级前先执行以下语句\n\n  ```mysql\n  alter table config_info add column    `encrypted_data_key` text NOT NULL COMMENT '秘钥';\n  alter table config_info_beta add column  `encrypted_data_key` text NOT NULL COMMENT '秘钥';\n  alter table his_config_info add column  `encrypted_data_key` text NOT NULL COMMENT '秘钥';\n  ```\n\n- Nacos `2.1.x`版本开始支持插件化，且鉴权作为插件化的形式引入，其配置文件值也相应做了更改，需要改动`applicaiton.properties`对应值\n\n  ```properties\n  # 默认鉴权插件用于生成用户登陆临时accessToken所使用的密钥\n  # 以下配置为2.1.x之前配置 需替换为 nacos.core.auth.plugin.nacos.token.secret.key\n  nacos.core.auth.default.token.secret.key=xxxx\n  # 以下配置为2.1.x之后配置\n  nacos.core.auth.plugin.nacos.token.secret.key=xxxx\n\n  # accessToken的过期时间\n  # 以下配置为2.1.x之前配置 需替换为 nacos.core.auth.plugin.nacos.token.expire.seconds\n  nacos.core.auth.default.token.expire.seconds=50\n  # 以下配置为2.1.x之后配置\n  nacos.core.auth.plugin.nacos.token.expire.seconds=50\n  ```\n\n  其中，`secretKey`之前版本存在默认值，存在安全风险，后续版本已去除默认值。\n  出于安全考虑不建议在生产环境使用默认值，如需修改，可参考官方公告方式进行修改[关于 Nacos 默认 token.secret.key 及 server.identity 风险说明及解决方案公告](https://nacos.io/zh-cn/blog/announcement-token-secret-key.html)\n\n- User-Agent 白名单修改\n\n  > 此选项非 Nacos`2.x`版本后的变更，但如需在升级过程中修改该配置，需要进行过渡处理\n\n  如需开启服务身份识别功能，禁用原先通过 User-Agent 的判断，可参考官方文档[开启服务身份识别功能](https://nacos.io/zh-cn/docs/v2/guide/user/auth.html)\n  在操作的过程中，建议先开启白名单判断(`nacos.core.auth.enable.userAgentAuthWhite`值修改为 true)，后保证认证头和值均发布到服务上后(`nacos.core.auth.server.identity.key`及`nacos.core.auth.server.identity.value`)再将`nacos.core.auth.enable.userAgentAuthWhite`值修改为 false\n\n- 升级集群中某一节点服务\n\n  > 对于 Docker/K8s 环境部署 Nacos 服务的情况，相当于滚动更新容器；对于虚拟机/物理机部署的情况，相当于停止旧 jar 包，使用新 jar 包启动\n\n  此处升级需注意，不仅是 jar 包的替换，新版本的`startup.sh`(或`docker-startup.sh`)亦可能有变化，需使用新版本的 shell 文件\n\n- 查看已经升级节点的日志文件，检查是否升级成功\n\n  - 检查 nacos.log\n  - 检查 core-auth.log\n  - 检查 naming-\\*.log\n\n- 重复上述两步骤，直到集群中所有节点均升级到新版本\n\n- 验证功能是否正常\n\n## 遇到的问题\n\n1.  升级后，客户端连接旧服务正常，连接新服务报 Invalid signature\n\n    > 包括 Console 下以及 Nacos Client 均可能出现这个情况\n\n    - 核心原因\n\n    Nacos 2.0.x 版本使用的是 jjwt 插件实现的 jwt 签发和鉴权，2.1.x 版本开始基于插件化实现，2.2.1 版本使用自研的 jwt 插件实现签发和鉴权，两者在对**secretKey**进行 Base64 解码的处理方式上存在不一致，如果原先的 secretKey 没有进行 Base64 编码，可能会存在此问题\n\n    > （我之前部署的就不是进行 Base64 编码的，记得之前部署的时候没说要设置 Base64 编码的..)\n\n    旧版本对于`secretKey`的处理方式为:在`com.alibaba.nacos.auth.common.AuthConfigs#getSecretKeyBytes`使用`io.jsonwebtoken.io.Decoder#decode`方法将 secretKey 转换成 byte 数组\n\n    > 这个方法对不规范的数据做了处理，会截断后面的数据\n\n    ![image-20230804145336259](Nacos-Upgrade/image-20230804145336259.png) <br/>\n    \n     新版本对于`secretKey`的处理方式为: 在实例化`com.alibaba.nacos.plugin.auth.impl.jwt.NacosJwtParser`时，使用`java.util.Base64.Decoder#decode(java.lang.String)`进行 Base64 解码，如果解码失败，直接获取 secretKey 的 byte 数组\n\n    ![image-20230804150621314](Nacos-Upgrade/image-20230804150621314.png)   <br/>\n\n\n    出现这个问题，很有可能是走到了 catch 逻辑中，导致 secretKey 的byte数组与之前的不一致，从而导致 JWT Token 签名校验失败，产生 Invalid signature 的错误\n\n    - 解决办法\n      jjwt 对不规范的数据采用截断方式，于是我想着把代码抽取出来成为独立的类，可以调用`convert()`对 secretKey 进行转换，入参为老版本 Nacos 配置的 secretKey，出参为新版本 Nacos 配置的 secretKey\n\n      ```java\n      /**\n       * @author xYohn\n       * @date 2023/8/4\n       */\n      public class KeyConvert {\n         private static final char[] BASE64_ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\".toCharArray();\n          private static final int[] BASE64_IALPHABET = new int[256];\n          private static final int IALPHABET_MAX_INDEX = BASE64_IALPHABET.length - 1;\n          private static final int[] IALPHABET = BASE64_IALPHABET;\n      \n          static {\n              Arrays.fill(BASE64_IALPHABET, -1);\n              for (int i = 0, iS = BASE64_ALPHABET.length; i < iS; i++) {\n                  BASE64_IALPHABET[BASE64_ALPHABET[i]] = i;\n              }\n              BASE64_IALPHABET['='] = 0;\n          }\n      \n          final static byte[] decodeFast(char[] sArr) {\n      \n              // Check special case\n              int sLen = sArr != null ? sArr.length : 0;\n              if (sLen == 0) {\n                  return new byte[0];\n              }\n      \n              int sIx = 0, eIx = sLen - 1;    // Start and end index after trimming.\n      \n              // Trim illegal chars from start\n              while (sIx < eIx && IALPHABET[sArr[sIx]] < 0) {\n                  sIx++;\n              }\n      \n              // Trim illegal chars from end\n              while (eIx > 0 && IALPHABET[sArr[eIx]] < 0) {\n                  eIx--;\n              }\n      \n              // get the padding count (=) (0, 1 or 2)\n              int pad = sArr[eIx] == '=' ? (sArr[eIx - 1] == '=' ? 2 : 1) : 0;  // Count '=' at end.\n              int cCnt = eIx - sIx + 1;   // Content count including possible separators\n              int sepCnt = sLen > 76 ? (sArr[76] == '\\r' ? cCnt / 78 : 0) << 1 : 0;\n      \n              int len = ((cCnt - sepCnt) * 6 >> 3) - pad; // The number of decoded bytes\n              byte[] dArr = new byte[len];       // Preallocate byte[] of exact length\n      \n              // Decode all but the last 0 - 2 bytes.\n              int d = 0;\n              for (int cc = 0, eLen = (len / 3) * 3; d < eLen; ) {\n      \n                  // Assemble three bytes into an int from four \"valid\" characters.\n                  int i = ctoi(sArr[sIx++]) << 18 | ctoi(sArr[sIx++]) << 12 | ctoi(sArr[sIx++]) << 6 | ctoi(sArr[sIx++]);\n      \n                  // Add the bytes\n                  dArr[d++] = (byte) (i >> 16);\n                  dArr[d++] = (byte) (i >> 8);\n                  dArr[d++] = (byte) i;\n      \n                  // If line separator, jump over it.\n                  if (sepCnt > 0 && ++cc == 19) {\n                      sIx += 2;\n                      cc = 0;\n                  }\n              }\n      \n              if (d < len) {\n                  // Decode last 1-3 bytes (incl '=') into 1-3 bytes\n                  int i = 0;\n                  for (int j = 0; sIx <= eIx - pad; j++) {\n                      i |= ctoi(sArr[sIx++]) << (18 - j * 6);\n                  }\n      \n                  for (int r = 16; d < len; r -= 8) {\n                      dArr[d++] = (byte) (i >> r);\n                  }\n              }\n      \n              return dArr;\n          }\n          private static int ctoi(char c) {\n              int i = c > IALPHABET_MAX_INDEX ? -1 : IALPHABET[c];\n              if (i < 0) {\n                  String msg = \"Illegal base64 character: '\" + c + \"'\";\n                  throw new RuntimeException(msg);\n              }\n              return i;\n          }\n      \n          public static String convert(String input){\n              return java.util.Base64.getEncoder().encodeToString(decodeFast(input.toCharArray()));\n          }\n          public static void main(String[] args) {\n              System.out.println(convert(\"secretKey\"));\n          }\n      }\n      \n      ```\n\n","tags":["Nacos","Java"]},{"title":"Hello World*n","url":"/2023/05/23/d2093ee40025/","content":"\n这应该是我 N 次有念头开博客了..\n\n想起来小学的时候接入了Discuz! ，立志想建一个班级网站(论坛)，但又不想花钱，所以四处在找免费的空间\n\n那时候还没有云的概念，免费的服务基本都是叫免费空间，分配一个ftp的账号，可能还带个MySQL的账密，供申请者使用\n\n那时候的备案还没那么严格，印象中还经历了好几家免费空间的兴衰，印象中还参加了新网的第一年CN域名免费活动\n\n但因为免费带来的不稳定性，资源总是迁移来迁移去，到最后就不知道到哪儿去了..\n\n后来高中大学通过 WordPress 建了几次博客，尤其是在大学，腾讯云对大学生有优惠，所以买了蛮长时间的云服务器\n\n有一段时间想着要开始分享自己在生活在学习上的知识，也写过几篇，但是后来没坚持下来\n\n主要是发现，写一篇自己满意的文章的成本，实在是太高了\n\n那时候还帮朋友做了一些自媒体的工作，帮忙写写自媒体稿写写自媒体评测，水稿确实轻轻松松就能来一篇，但是原创的个人感觉有深度的，确实要花费很长的时间和精力\n\n那时候自媒体算是兴起的阶段，尤其是做程序员相关的自媒体，那段时间我看到了大量的洗稿，看到了大量的水稿，当然也有看到蛮多的质量稿，但后续开始有流量开始接广告后，emmm，又变成了划水自媒体\n\n那时候觉得自媒体是一个门槛很低也很高的行业，很低是注册一个账号太简单了，任何人只要有想法都可以是自媒体，各大平台的关于自媒体的补贴也很多，大家都可以从中得益；很高是真正有水平有内涵的自媒体，要在这成群涌入的从业者里脱颖而出，不是一件简单的事情。\n\n而我在这个时间段里写的自媒体相关的文章，有的确实也火了(当然也离不开朋友的推广)，很开心，但被其他自媒体洗稿或是直接抄袭标识原创的时候，又有点难过。\n\n低门槛及行业的一些乱象，也让我觉得这个行业，它不应该是我后续继续从事的行业\n\n我也算是经历了自媒体的起步阶段？(笑)\n\n---\n\n至于这一次又开始了开博客的念头，有一部分原因是想尝试下静态化CMS的体验\n\n这几年工作上接触过不少业务，近期主要在做的是企业级的CMS平台\n\n考虑到各种因素，企业级的CMS基本上都是以根据模板生成静态页面为主\n\n而以前无论是建论坛还是建个人博客，基本上都是动态语言\n\n有一天静下心来一想，我一个在做企业级CMS的开发人员，怎么能连一个静态化的博客都没有\n\n除了分享日常以外，写写置标也好，玩转插件也罢，得让自己对这一类产品有更多的了解，才能有更多的想法和看法\n\n我一直觉得，做产品，做产品经理，如果自己都玩不转自己的产品，自己所处行业的产品，那是没法真正洞察用户所需，没法真正做出好产品的\n\n这样的产品只能是自嗨，也只配是自嗨\n\n开发人员也一样，如果没有对现有产品的了解，没有对行业标杆的了解，也没法为需求设计出更优的架构，没法为产品提升可维护性和可演化性，尤其是面对像CMS这种既面向内容输出用户，又面向开发人员的产品\n\n所以，今天开始，也算是我自己又写了一个hello world\n\n\n\n\n\n","tags":["essay"]}]